---
layout: post
title: Using mpremote
---

A few years ago I started to get into playing with hardware. I wanted to build something
that would monitor the temperature in our office and send a message to change the
environmental controls if the temperature got outwith set boundaries. To this end I bought
a shiny new Raspberry Pi 4 B+, a DHT20 temperature sensor, and a bundle of DuPont wires
from the excellent [PiHut](thepihut.com). I had fun playing with the little sensor chip
and working out how to speak to the thing which resulted in me writing some very basic
code which has benefited at least one other person!

Later I got the [12 Projects Of Codemas Maker Advent Calender](https://thepihut.com/products/maker-advent-calendar-includes-raspberry-pi-pico-h) 
for myself instead of doing Advent Of Code as I'd got fed up of getting stuck after day 4!
Said calendar includes a Raspberry Pi Pico H. This was my first time using a 
microcontroller and I'd not really given much thought as to how you go about getting your
code onto the device.

The Maker calendar and indeed the [Raspberry Pi Official Magazine](https://magazine.raspberrypi.com/)
in all of the articles I've ever read suggest using [Thonny](https://thonny.org/).
Thonny is a Python IDE aimed at people new to programming and indeed it is/was
apparently supported by the Raspberry Pi foundation. Amongst other features, Thonny allows you to move and copy files 
between a microcontroller and the host filesystem with a GUI.

Now that's all well and good, but I'm a fancy pants person who writes software for a living
and I've been using vim (specifically LazyVim) for a long time now. I don't want to use an IDE! I barely even
use Vim plugins beyond formatting, I just do everything in the terminal.
Enter [mpremote](https://docs.micropython.org/en/latest/reference/mpremote.html) which lets you perform a whole host of useful actions from the comfort and configurability of your own terminal.

# Connecting To A Device

I've found this more or less difficult depending on which computer I'm using. The first
step is to connect your device (running either MicroPython or CircuitPython) to your
computer via USB. When connecting say the Pico to my Raspberry Pi 4, I can simply run

```
mpremote
```

and I'm dumped into a REPL.

## No Device Found :(

On my laptop running Ubuntu, it's a _tiny_ bit trickier. When I first tried to connect with mpremote I would just get a `no device found`
error. After some googling I found that it was likely to be a permissions issue.
First thing's first is to find which serial port mpremote needs to connect to.
Unplug the microcontroller and then run

```
sudo udevadm monitor -u
```

Then plug the microcontroller back in. At this point you should see several lines appear in the monitor.

![udevadm monitor output upon plugging in and unplugging a Pico via usb](/assets/udev.png)

One of these will have `(tty)` at the end. Unplugging the Pico causes another set of lines indicating the device was disconnected.
Once you've found the correct serial port you need to give yourself read and write permissions on it. In my case my Pico 
at least always appears as `ttyACM0` and so I need to run

```
sudo chmod a+rw /dev/ttyACM0
```

Once that's done, just `mpremote` is enough to drop me into the REPL.

# Filesystem Operations

Moving files to and from the connected device and the host machine is relatively straightforward,
though personally I find it quite tricky to know what directories exactly are available
on the connected device.

Essentially you can run any filesytem command you would run on your own terminal prefaced
by `fs` to indicate that mpremote is executing a filesystem command. For example the following

```
mpremote fs ls
```

executes `ls` on the device filesytem. In the case of the Pico currently connected to my laptop,
this gives the following output.

![Output of running mpremote fs ls](/assets/ls.png)

The Pico has a file named `main.py` and a directory `/lib`. A further command
`mpremote fs ls lib` lists the contents of the `/lib` directory.

![Output of running mpremote fs ls lib](/assets/ls_lib.png)

The file present is the ssd1306 MicroPython driver for using a little OLED display.
I installed that using `mip`, but that's for another day.

## Main

The file `main.py` is important as this is what will be executed when the device is powered on.
If you want something to be run when you supply power to your Pico for example, you need
the script or entrypoint to be named `main.py`. Note that the file as you work on it doesn't
have to be called main, so long as it's `main.py` on the device filesytem.

You can run any script you like on the connected device regardless of its name and see
any output in the terminal with

```
mpremote run some_script.py
```

When you've decided that whatever `some_script.py` does is whatever your device should do
when it's powered on, you can copy it to the device as `main.py` using

```
mpremote fs cp my_exciting_script.py :main.py
```

Note the `:` in front of `main.py`. This is very important! A bit like when using `scp` over ssh,
you've got two filesystems involved in this command: the host machine (your laptop/whatever) 
and the client machine (for example my Pico). The colon denotes the client filesystem,
so in my case the Pico. This copies `my_exciting_script.py` to the target device as `main.py`,
and so it will be executed whenever the device is powered on.

# It's not mpremote-ly difficult!

If you're used to doing things in the terminal I definitely think mpremote is the way to go.
It's also handy potentially if you think Thonny itself is doing something funny.
Beyond simply development it can also come in handy for automating installations etc.
When I get round to it I'll write a post on using mpremote with `mip` for handling dependencies.

In the main I mostly only need `mpremote` to try things in the REPL, `mpremote run` to try
out a script, and the most basic filesystem commands. If you look at the documentation however,
you'll see it can do absolutely shed loads. Enjoy!
